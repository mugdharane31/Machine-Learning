# -*- coding: utf-8 -*-
"""ML_assignment2_question1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1O9dhX2uMUDEnFcaQuQB_bNn3yyJS6hX6
"""

#import all the necessary libraries
import numpy as np
import matplotlib.pyplot as plt
from scipy.io import loadmat 
from numpy import exp, log, absolute
from numpy.linalg import norm

#this function returns the label{-1,1} depending on value of y
# y - input dataset
def setLabel(y):
    y[y>=0]=1;y[y<0]=-1
    return y

#this method calculates the risk depending on the y and predicted y and N
#y - input dataset
#y_pred -
#N - Pseudo random numbers generated using numpy library
def returnRisk(y, y_pred, N):
    assert(y.shape[-1]==1)
    risk = np.sum(setLabel(np.multiply(-y, y_pred))) #risk formula
    return risk/N #average

# this function returns the error using the formula for error
def returnError(y, y_pred, N):
    return float(np.count_nonzero(setLabel(y_pred)!=y))/N #average

# this function returns the weights, iterations, error_list, risk_list
#iterations - maximum number of iterations
#learningRate - the eetah value
#opts - dict type containing key value of max_iterations and learning 
#x, y - input dataset
def LearningRate(x, y, opts):
    sample_nums, features_num = x.shape
    max_iterations  = opts['max_iterations']
    learningRate         = opts['learningRate']
    #weights = random floats in the half-open interval [features_num, 1].
    weights    = np.random.random_sample((features_num, 1))
    error_list = []
    risk_list  = []
    iterations = 0

    while iterations < max_iterations:
        #Generate pseudo-random numbers and put them in sample_nums
        i = np.random.randint(sample_nums)
        output = x[i].reshape((1,3)).dot(weights)
        # print(output, y[i])

        #if the condition is true update the error_list and risk_list
        if setLabel(np.multiply(y[i],output))[0]==-1:
            weights += learningRate * x[i].reshape((3, 1)).dot(y[i].reshape((1,1)))
            y_pred = x.dot(weights)
            #we use the above declared returnError and returnRisk functions to update error_list and risk_list
            error_list.append(returnError(y, y_pred, sample_nums))
            risk_list.append(returnRisk(y, y_pred, sample_nums))
            print(error_list[iterations], iterations)
            iterations += 1 #next iteration
            if error_list[-1]==0:
                break

    return weights, iterations, error_list, risk_list

#function used to plot the model- blue line
#basic function which uses python libraries to plot the graph
#weights - this paramaters is returned from learningRate function
#x,y - input dataset
def show_model(weights, x, y):
    plt.figure(0)
    sample_nums = x.shape[0]
    for i in range(sample_nums):
        plt.plot(x[i, 0], x[i, 1], 'r.')
    min_x = min(x[:, 0])
    max_x = max(x[:, 0])
    y_min_x = float(-weights[2] - weights[0] * min_x) / weights[1]
    y_max_x = float(-weights[2] - weights[0] * max_x) / weights[1]
    plt.plot([min_x, max_x], [y_min_x, y_max_x], '-b')
    plt.xlabel('X1'); plt.ylabel('X2')
    plt.show()

#this function plots the error graph
#basic function which uses python libraries to plot the graph
#iteration - number of iterations
#error_list, risk_list - input
def show_err_graph(iterations, error_list, risk_list):
    plt.figure(1)
    plt.plot(range(iterations), error_list,'r-',label='Error')
    plt.plot(range(iterations), risk_list, 'g-',label='Risk')
    plt.xlabel('Iterations')
    plt.title('Error/Risk-Iteration')
    plt.legend()
    plt.show()

if __name__=="__main__":
  #load data from the dataset(data3.mat)
    matdata = loadmat('drive/MyDrive/data3.mat')
    _x = matdata['data'][:,:2]
    y  = matdata['data'][:,-1:]
    x  = np.concatenate((_x, np.ones((_x.shape[0],1))), axis=1)
    # print(x.shape)
    # print(y[0].shape, x[0].shape)

    #max_iters - the maximum iterations - this can be changed as per needs
    #learningRate - the eetah value - this can be changed as per needs
    max_iterations = 5000

    #opts - dict type containing key value of max_iterations and learning rate
    opts  = {'max_iterations': max_iterations, 'learningRate': 0.2} 
    
    weights, iterations, error_list, risk_list= LearningRate(x, y, opts)
    # print(iterations)
    show_model(weights, x, y)
    show_err_graph(iterations, error_list, risk_list)
